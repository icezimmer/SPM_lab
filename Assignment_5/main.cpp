#include <iostream>
#include <functional>
#include <thread>
#include <omp.h>
#include "utils.cpp"
#include "utimer.cpp"

int main(int argc, char **argv) {
  
    if(argc != 5 && argc != 4) {
        cout << "Usage is: " << argv[0] << " max-value time_arrival time_computation [num_thread] " << endl;
        return -1;
    }

    int max   = atoi(argv[1]);
    int ta    = atoi(argv[2]);
    int tf    = atoi(argv[3]);
    int nw = argc > 4 ? atoi(argv[4]) : thread::hardware_concurrency();

    function<void(float)> f = [&] (float x) { 
            active_delay(tf);
            float res = x * x;
            #pragma omp critical
                cout << res << endl;
            return;
        };


    #pragma omp parallel num_threads(nw)
    {
        // Executed by a single thread, we could use also #pragma omp master
        #pragma omp single
        {
            for(int i=0;i<max;i++){
                active_delay(ta);
                auto t = bind(f,i);
                cout << "Task " << i << endl;
                // Use the task pragma when you want to identify a block of code
                // to be execute in parallel with the code outside the task region
                #pragma omp task
                t();
            }
            auto p = [] () {cout << "Questo lo prendi?" << endl; return;};
            #pragma omp task
            p();

        } // Implicit barrier

        // Use the taskwait pragma to specify a wait for child tasks
        // to be completed that are generated by the current task
        #pragma omp taskwait
    }
}
